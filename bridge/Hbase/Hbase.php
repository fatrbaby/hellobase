<?php
namespace Hbase;
/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface HbaseIf {
  /**
   * Brings a table on-line (enables it)
   * 
   * @param string $tableName name of the table
   * 
   * @throws \Hbase\IOError
   */
  public function enableTable($tableName);
  /**
   * Disables a table (takes it off-line) If it is being served, the master
   * will tell the servers to stop serving it.
   * 
   * @param string $tableName name of the table
   * 
   * @throws \Hbase\IOError
   */
  public function disableTable($tableName);
  /**
   * @return true if table is on-line
   * 
   * @param string $tableName name of the table to check
   * 
   * @return bool
   * @throws \Hbase\IOError
   */
  public function isTableEnabled($tableName);
  /**
   * @param string $tableNameOrRegionName
   * @throws \Hbase\IOError
   */
  public function compact($tableNameOrRegionName);
  /**
   * @param string $tableNameOrRegionName
   * @throws \Hbase\IOError
   */
  public function majorCompact($tableNameOrRegionName);
  /**
   * List all the userspace tables.
   * 
   * @return returns a list of names
   * 
   * @return string[]
   * @throws \Hbase\IOError
   */
  public function getTableNames();
  /**
   * List all the column families assoicated with a table.
   * 
   * @return list of column family descriptors
   * 
   * @param string $tableName table name
   * 
   * @return array
   * @throws \Hbase\IOError
   */
  public function getColumnDescriptors($tableName);
  /**
   * List the regions associated with a table.
   * 
   * @return list of region descriptors
   * 
   * @param string $tableName table name
   * 
   * @return \Hbase\TRegionInfo[]
   * @throws \Hbase\IOError
   */
  public function getTableRegions($tableName);
  /**
   * Create a table with the specified column families.  The name
   * field for each ColumnDescriptor must be set and must end in a
   * colon (:). All other fields are optional and will get default
   * values if not explicitly specified.
   * 
   * @throws IllegalArgument if an input parameter is invalid
   * 
   * @throws AlreadyExists if the table name already exists
   * 
   * @param string $tableName name of table to create
   * 
   * @param \Hbase\ColumnDescriptor[] $columnFamilies list of column family descriptors
   * 
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   * @throws \Hbase\AlreadyExists
   */
  public function createTable($tableName, array $columnFamilies);
  /**
   * Deletes a table
   * 
   * @throws IOError if table doesn't exist on server or there was some other
   * problem
   * 
   * @param string $tableName name of table to delete
   * 
   * @throws \Hbase\IOError
   */
  public function deleteTable($tableName);
  /**
   * Get a single TCell for the specified table, row, and column at the
   * latest timestamp. Returns an empty list if no such value exists.
   * 
   * @return value for specified row/column
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param string $column column name
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TCell[]
   * @throws \Hbase\IOError
   */
  public function get($tableName, $row, $column, array $attributes);
  /**
   * Get the specified number of versions for the specified table,
   * row, and column.
   * 
   * @return list of cells for specified row/column
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param string $column column name
   * 
   * @param int $numVersions number of versions to retrieve
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TCell[]
   * @throws \Hbase\IOError
   */
  public function getVer($tableName, $row, $column, $numVersions, array $attributes);
  /**
   * Get the specified number of versions for the specified table,
   * row, and column.  Only versions less than or equal to the specified
   * timestamp will be returned.
   * 
   * @return list of cells for specified row/column
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param string $column column name
   * 
   * @param int $timestamp timestamp
   * 
   * @param int $numVersions number of versions to retrieve
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TCell[]
   * @throws \Hbase\IOError
   */
  public function getVerTs($tableName, $row, $column, $timestamp, $numVersions, array $attributes);
  /**
   * Get all the data for the specified table and row at the latest
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRow($tableName, $row, array $attributes);
  /**
   * Get the specified columns for the specified table and row at the latest
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param string[] $columns List of columns to return, null for all columns
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRowWithColumns($tableName, $row, array $columns, array $attributes);
  /**
   * Get all the data for the specified table and row at the specified
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param string $tableName name of the table
   * 
   * @param string $row row key
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRowTs($tableName, $row, $timestamp, array $attributes);
  /**
   * Get the specified columns for the specified table and row at the specified
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param string[] $columns List of columns to return, null for all columns
   * 
   * @param int $timestamp
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRowWithColumnsTs($tableName, $row, array $columns, $timestamp, array $attributes);
  /**
   * Get all the data for the specified table and rows at the latest
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param string $tableName name of table
   * 
   * @param string[] $rows row keys
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRows($tableName, array $rows, array $attributes);
  /**
   * Get the specified columns for the specified table and rows at the latest
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param string $tableName name of table
   * 
   * @param string[] $rows row keys
   * 
   * @param string[] $columns List of columns to return, null for all columns
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRowsWithColumns($tableName, array $rows, array $columns, array $attributes);
  /**
   * Get all the data for the specified table and rows at the specified
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param string $tableName name of the table
   * 
   * @param string[] $rows row keys
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRowsTs($tableName, array $rows, $timestamp, array $attributes);
  /**
   * Get the specified columns for the specified table and rows at the specified
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param string $tableName name of table
   * 
   * @param string[] $rows row keys
   * 
   * @param string[] $columns List of columns to return, null for all columns
   * 
   * @param int $timestamp
   * @param array $attributes Get attributes
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   */
  public function getRowsWithColumnsTs($tableName, array $rows, array $columns, $timestamp, array $attributes);
  /**
   * Apply a series of mutations (updates/deletes) to a row in a
   * single transaction.  If an exception is thrown, then the
   * transaction is aborted.  Default current timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param \Hbase\Mutation[] $mutations list of mutation commands
   * 
   * @param array $attributes Mutation attributes
   * 
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function mutateRow($tableName, $row, array $mutations, array $attributes);
  /**
   * Apply a series of mutations (updates/deletes) to a row in a
   * single transaction.  If an exception is thrown, then the
   * transaction is aborted.  The specified timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param \Hbase\Mutation[] $mutations list of mutation commands
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Mutation attributes
   * 
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function mutateRowTs($tableName, $row, array $mutations, $timestamp, array $attributes);
  /**
   * Apply a series of batches (each a series of mutations on a single row)
   * in a single transaction.  If an exception is thrown, then the
   * transaction is aborted.  Default current timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param string $tableName name of table
   * 
   * @param \Hbase\BatchMutation[] $rowBatches list of row batches
   * 
   * @param array $attributes Mutation attributes
   * 
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function mutateRows($tableName, array $rowBatches, array $attributes);
  /**
   * Apply a series of batches (each a series of mutations on a single row)
   * in a single transaction.  If an exception is thrown, then the
   * transaction is aborted.  The specified timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param string $tableName name of table
   * 
   * @param \Hbase\BatchMutation[] $rowBatches list of row batches
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Mutation attributes
   * 
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function mutateRowsTs($tableName, array $rowBatches, $timestamp, array $attributes);
  /**
   * Atomically increment the column value specified.  Returns the next value post increment.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row to increment
   * 
   * @param string $column name of column
   * 
   * @param int $value amount to increment by
   * 
   * @return int
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function atomicIncrement($tableName, $row, $column, $value);
  /**
   * Delete all cells that match the passed row and column.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row Row to update
   * 
   * @param string $column name of column whose value is to be deleted
   * 
   * @param array $attributes Delete attributes
   * 
   * @throws \Hbase\IOError
   */
  public function deleteAll($tableName, $row, $column, array $attributes);
  /**
   * Delete all cells that match the passed row and column and whose
   * timestamp is equal-to or older than the passed timestamp.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row Row to update
   * 
   * @param string $column name of column whose value is to be deleted
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Delete attributes
   * 
   * @throws \Hbase\IOError
   */
  public function deleteAllTs($tableName, $row, $column, $timestamp, array $attributes);
  /**
   * Completely delete the row's cells.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row key of the row to be completely deleted.
   * 
   * @param array $attributes Delete attributes
   * 
   * @throws \Hbase\IOError
   */
  public function deleteAllRow($tableName, $row, array $attributes);
  /**
   * Increment a cell by the ammount.
   * Increments can be applied async if hbase.regionserver.thrifts.coalesceIncrement is set to true.
   * False is the default.  Turn to true if you need the extra performance and can accept some
   * data loss if a thrifts server dies with increments still in the queue.
   * 
   * @param \Hbase\TIncrement $increment The single increment to apply
   * 
   * @throws \Hbase\IOError
   */
  public function increment(\Hbase\TIncrement $increment);
  /**
   * @param \Hbase\TIncrement[] $increments The list of increments
   * 
   * @throws \Hbase\IOError
   */
  public function incrementRows(array $increments);
  /**
   * Completely delete the row's cells marked with a timestamp
   * equal-to or older than the passed timestamp.
   * 
   * @param string $tableName name of table
   * 
   * @param string $row key of the row to be completely deleted.
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Delete attributes
   * 
   * @throws \Hbase\IOError
   */
  public function deleteAllRowTs($tableName, $row, $timestamp, array $attributes);
  /**
   * Get a scanner on the current table, using the Scan instance
   * for the scan parameters.
   * 
   * @param string $tableName name of table
   * 
   * @param \Hbase\TScan $scan Scan instance
   * 
   * @param array $attributes Scan attributes
   * 
   * @return int
   * @throws \Hbase\IOError
   */
  public function scannerOpenWithScan($tableName, \Hbase\TScan $scan, array $attributes);
  /**
   * Get a scanner on the current table starting at the specified row and
   * ending at the last row in the table.  Return the specified columns.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param string $tableName name of table
   * 
   * @param string $startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param string[] $columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param array $attributes Scan attributes
   * 
   * @return int
   * @throws \Hbase\IOError
   */
  public function scannerOpen($tableName, $startRow, array $columns, array $attributes);
  /**
   * Get a scanner on the current table starting and stopping at the
   * specified rows.  ending at the last row in the table.  Return the
   * specified columns.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param string $tableName name of table
   * 
   * @param string $startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param string $stopRow row to stop scanning on. This row is *not* included in the
   * scanner's results
   * 
   * @param string[] $columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param array $attributes Scan attributes
   * 
   * @return int
   * @throws \Hbase\IOError
   */
  public function scannerOpenWithStop($tableName, $startRow, $stopRow, array $columns, array $attributes);
  /**
   * Open a scanner for a given prefix.  That is all rows will have the specified
   * prefix. No other rows will be returned.
   * 
   * @return scanner id to use with other scanner calls
   * 
   * @param string $tableName name of table
   * 
   * @param string $startAndPrefix the prefix (and thus start row) of the keys you want
   * 
   * @param string[] $columns the columns you want returned
   * 
   * @param array $attributes Scan attributes
   * 
   * @return int
   * @throws \Hbase\IOError
   */
  public function scannerOpenWithPrefix($tableName, $startAndPrefix, array $columns, array $attributes);
  /**
   * Get a scanner on the current table starting at the specified row and
   * ending at the last row in the table.  Return the specified columns.
   * Only values with the specified timestamp are returned.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param string $tableName name of table
   * 
   * @param string $startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param string[] $columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Scan attributes
   * 
   * @return int
   * @throws \Hbase\IOError
   */
  public function scannerOpenTs($tableName, $startRow, array $columns, $timestamp, array $attributes);
  /**
   * Get a scanner on the current table starting and stopping at the
   * specified rows.  ending at the last row in the table.  Return the
   * specified columns.  Only values with the specified timestamp are
   * returned.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param string $tableName name of table
   * 
   * @param string $startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param string $stopRow row to stop scanning on. This row is *not* included in the
   * scanner's results
   * 
   * @param string[] $columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param int $timestamp timestamp
   * 
   * @param array $attributes Scan attributes
   * 
   * @return int
   * @throws \Hbase\IOError
   */
  public function scannerOpenWithStopTs($tableName, $startRow, $stopRow, array $columns, $timestamp, array $attributes);
  /**
   * Returns the scanner's current row value and advances to the next
   * row in the table.  When there are no more rows in the table, or a key
   * greater-than-or-equal-to the scanner's specified stopRow is reached,
   * an empty list is returned.
   * 
   * @return a TRowResult containing the current row and a map of the columns to TCells.
   * 
   * @throws IllegalArgument if ScannerID is invalid
   * 
   * @throws NotFound when the scanner reaches the end
   * 
   * @param int $id id of a scanner returned by scannerOpen
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function scannerGet($id);
  /**
   * Returns, starting at the scanner's current row value nbRows worth of
   * rows and advances to the next row in the table.  When there are no more
   * rows in the table, or a key greater-than-or-equal-to the scanner's
   * specified stopRow is reached,  an empty list is returned.
   * 
   * @return a TRowResult containing the current row and a map of the columns to TCells.
   * 
   * @throws IllegalArgument if ScannerID is invalid
   * 
   * @throws NotFound when the scanner reaches the end
   * 
   * @param int $id id of a scanner returned by scannerOpen
   * 
   * @param int $nbRows number of results to return
   * 
   * @return \Hbase\TRowResult[]
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function scannerGetList($id, $nbRows);
  /**
   * Closes the server-state associated with an open scanner.
   * 
   * @throws IllegalArgument if ScannerID is invalid
   * 
   * @param int $id id of a scanner returned by scannerOpen
   * 
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function scannerClose($id);
  /**
   * Get the regininfo for the specified row. It scans
   * the metatable to find region's start and end keys.
   * 
   * @return value for specified row/column
   * 
   * @param string $row row key
   * 
   * @return \Hbase\TRegionInfo A TRegionInfo contains information about an HTable region.
   * 
   * @throws \Hbase\IOError
   */
  public function getRegionInfo($row);
  /**
   * Appends values to one or more columns within a single row.
   * 
   * @return values of columns after the append operation.
   * 
   * @param \Hbase\TAppend $append The single append operation to apply
   * 
   * @return \Hbase\TCell[]
   * @throws \Hbase\IOError
   */
  public function append(\Hbase\TAppend $append);
  /**
   * Atomically checks if a row/family/qualifier value matches the expected
   * value. If it does, it adds the corresponding mutation operation for pick.
   * 
   * @return true if the new pick was executed, false otherwise
   * 
   * @param string $tableName name of table
   * 
   * @param string $row row key
   * 
   * @param string $column column name
   * 
   * @param string $value the expected value for the column parameter, if not
   * provided the check is for the non-existence of the
   * column in question
   * 
   * @param \Hbase\Mutation $mput mutation for the pick
   * 
   * @param array $attributes Mutation attributes
   * 
   * @return bool
   * @throws \Hbase\IOError
   * @throws \Hbase\IllegalArgument
   */
  public function checkAndPut($tableName, $row, $column, $value, \Hbase\Mutation $mput, array $attributes);
}


class HbaseClient implements \Hbase\HbaseIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function enableTable($tableName)
  {
    $this->send_enableTable($tableName);
    $this->recv_enableTable();
  }

  public function send_enableTable($tableName)
  {
    $args = new \Hbase\Hbase_enableTable_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'enableTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('enableTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_enableTable()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_enableTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_enableTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function disableTable($tableName)
  {
    $this->send_disableTable($tableName);
    $this->recv_disableTable();
  }

  public function send_disableTable($tableName)
  {
    $args = new \Hbase\Hbase_disableTable_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'disableTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('disableTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_disableTable()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_disableTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_disableTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function isTableEnabled($tableName)
  {
    $this->send_isTableEnabled($tableName);
    return $this->recv_isTableEnabled();
  }

  public function send_isTableEnabled($tableName)
  {
    $args = new \Hbase\Hbase_isTableEnabled_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'isTableEnabled', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('isTableEnabled', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_isTableEnabled()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_isTableEnabled_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_isTableEnabled_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("isTableEnabled failed: unknown result");
  }

  public function compact($tableNameOrRegionName)
  {
    $this->send_compact($tableNameOrRegionName);
    $this->recv_compact();
  }

  public function send_compact($tableNameOrRegionName)
  {
    $args = new \Hbase\Hbase_compact_args();
    $args->tableNameOrRegionName = $tableNameOrRegionName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'compact', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('compact', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_compact()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_compact_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_compact_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function majorCompact($tableNameOrRegionName)
  {
    $this->send_majorCompact($tableNameOrRegionName);
    $this->recv_majorCompact();
  }

  public function send_majorCompact($tableNameOrRegionName)
  {
    $args = new \Hbase\Hbase_majorCompact_args();
    $args->tableNameOrRegionName = $tableNameOrRegionName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'majorCompact', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('majorCompact', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_majorCompact()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_majorCompact_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_majorCompact_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function getTableNames()
  {
    $this->send_getTableNames();
    return $this->recv_getTableNames();
  }

  public function send_getTableNames()
  {
    $args = new \Hbase\Hbase_getTableNames_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableNames', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableNames', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableNames()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getTableNames_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getTableNames_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getTableNames failed: unknown result");
  }

  public function getColumnDescriptors($tableName)
  {
    $this->send_getColumnDescriptors($tableName);
    return $this->recv_getColumnDescriptors();
  }

  public function send_getColumnDescriptors($tableName)
  {
    $args = new \Hbase\Hbase_getColumnDescriptors_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getColumnDescriptors', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getColumnDescriptors', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getColumnDescriptors()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getColumnDescriptors_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getColumnDescriptors_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getColumnDescriptors failed: unknown result");
  }

  public function getTableRegions($tableName)
  {
    $this->send_getTableRegions($tableName);
    return $this->recv_getTableRegions();
  }

  public function send_getTableRegions($tableName)
  {
    $args = new \Hbase\Hbase_getTableRegions_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableRegions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableRegions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableRegions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getTableRegions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getTableRegions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getTableRegions failed: unknown result");
  }

  public function createTable($tableName, array $columnFamilies)
  {
    $this->send_createTable($tableName, $columnFamilies);
    $this->recv_createTable();
  }

  public function send_createTable($tableName, array $columnFamilies)
  {
    $args = new \Hbase\Hbase_createTable_args();
    $args->tableName = $tableName;
    $args->columnFamilies = $columnFamilies;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'createTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('createTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_createTable()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_createTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_createTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    if ($result->exist !== null) {
      throw $result->exist;
    }
    return;
  }

  public function deleteTable($tableName)
  {
    $this->send_deleteTable($tableName);
    $this->recv_deleteTable();
  }

  public function send_deleteTable($tableName)
  {
    $args = new \Hbase\Hbase_deleteTable_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteTable()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_deleteTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_deleteTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function get($tableName, $row, $column, array $attributes)
  {
    $this->send_get($tableName, $row, $column, $attributes);
    return $this->recv_get();
  }

  public function send_get($tableName, $row, $column, array $attributes)
  {
    $args = new \Hbase\Hbase_get_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_get_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_get_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("get failed: unknown result");
  }

  public function getVer($tableName, $row, $column, $numVersions, array $attributes)
  {
    $this->send_getVer($tableName, $row, $column, $numVersions, $attributes);
    return $this->recv_getVer();
  }

  public function send_getVer($tableName, $row, $column, $numVersions, array $attributes)
  {
    $args = new \Hbase\Hbase_getVer_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->numVersions = $numVersions;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getVer', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getVer', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getVer()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getVer_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getVer_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getVer failed: unknown result");
  }

  public function getVerTs($tableName, $row, $column, $timestamp, $numVersions, array $attributes)
  {
    $this->send_getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
    return $this->recv_getVerTs();
  }

  public function send_getVerTs($tableName, $row, $column, $timestamp, $numVersions, array $attributes)
  {
    $args = new \Hbase\Hbase_getVerTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->timestamp = $timestamp;
    $args->numVersions = $numVersions;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getVerTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getVerTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getVerTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getVerTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getVerTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getVerTs failed: unknown result");
  }

  public function getRow($tableName, $row, array $attributes)
  {
    $this->send_getRow($tableName, $row, $attributes);
    return $this->recv_getRow();
  }

  public function send_getRow($tableName, $row, array $attributes)
  {
    $args = new \Hbase\Hbase_getRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRow()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRow failed: unknown result");
  }

  public function getRowWithColumns($tableName, $row, array $columns, array $attributes)
  {
    $this->send_getRowWithColumns($tableName, $row, $columns, $attributes);
    return $this->recv_getRowWithColumns();
  }

  public function send_getRowWithColumns($tableName, $row, array $columns, array $attributes)
  {
    $args = new \Hbase\Hbase_getRowWithColumns_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columns = $columns;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumns()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRowWithColumns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRowWithColumns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRowWithColumns failed: unknown result");
  }

  public function getRowTs($tableName, $row, $timestamp, array $attributes)
  {
    $this->send_getRowTs($tableName, $row, $timestamp, $attributes);
    return $this->recv_getRowTs();
  }

  public function send_getRowTs($tableName, $row, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_getRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRowTs failed: unknown result");
  }

  public function getRowWithColumnsTs($tableName, $row, array $columns, $timestamp, array $attributes)
  {
    $this->send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
    return $this->recv_getRowWithColumnsTs();
  }

  public function send_getRowWithColumnsTs($tableName, $row, array $columns, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_getRowWithColumnsTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumnsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumnsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumnsTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRowWithColumnsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRowWithColumnsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRowWithColumnsTs failed: unknown result");
  }

  public function getRows($tableName, array $rows, array $attributes)
  {
    $this->send_getRows($tableName, $rows, $attributes);
    return $this->recv_getRows();
  }

  public function send_getRows($tableName, array $rows, array $attributes)
  {
    $args = new \Hbase\Hbase_getRows_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRows', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRows', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRows()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRows_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRows_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRows failed: unknown result");
  }

  public function getRowsWithColumns($tableName, array $rows, array $columns, array $attributes)
  {
    $this->send_getRowsWithColumns($tableName, $rows, $columns, $attributes);
    return $this->recv_getRowsWithColumns();
  }

  public function send_getRowsWithColumns($tableName, array $rows, array $columns, array $attributes)
  {
    $args = new \Hbase\Hbase_getRowsWithColumns_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->columns = $columns;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowsWithColumns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowsWithColumns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowsWithColumns()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRowsWithColumns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRowsWithColumns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRowsWithColumns failed: unknown result");
  }

  public function getRowsTs($tableName, array $rows, $timestamp, array $attributes)
  {
    $this->send_getRowsTs($tableName, $rows, $timestamp, $attributes);
    return $this->recv_getRowsTs();
  }

  public function send_getRowsTs($tableName, array $rows, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_getRowsTs_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowsTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRowsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRowsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRowsTs failed: unknown result");
  }

  public function getRowsWithColumnsTs($tableName, array $rows, array $columns, $timestamp, array $attributes)
  {
    $this->send_getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
    return $this->recv_getRowsWithColumnsTs();
  }

  public function send_getRowsWithColumnsTs($tableName, array $rows, array $columns, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_getRowsWithColumnsTs_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowsWithColumnsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowsWithColumnsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowsWithColumnsTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRowsWithColumnsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRowsWithColumnsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRowsWithColumnsTs failed: unknown result");
  }

  public function mutateRow($tableName, $row, array $mutations, array $attributes)
  {
    $this->send_mutateRow($tableName, $row, $mutations, $attributes);
    $this->recv_mutateRow();
  }

  public function send_mutateRow($tableName, $row, array $mutations, array $attributes)
  {
    $args = new \Hbase\Hbase_mutateRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->mutations = $mutations;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRow()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_mutateRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_mutateRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRowTs($tableName, $row, array $mutations, $timestamp, array $attributes)
  {
    $this->send_mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
    $this->recv_mutateRowTs();
  }

  public function send_mutateRowTs($tableName, $row, array $mutations, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_mutateRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->mutations = $mutations;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRowTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_mutateRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_mutateRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRows($tableName, array $rowBatches, array $attributes)
  {
    $this->send_mutateRows($tableName, $rowBatches, $attributes);
    $this->recv_mutateRows();
  }

  public function send_mutateRows($tableName, array $rowBatches, array $attributes)
  {
    $args = new \Hbase\Hbase_mutateRows_args();
    $args->tableName = $tableName;
    $args->rowBatches = $rowBatches;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRows', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRows', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRows()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_mutateRows_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_mutateRows_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRowsTs($tableName, array $rowBatches, $timestamp, array $attributes)
  {
    $this->send_mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
    $this->recv_mutateRowsTs();
  }

  public function send_mutateRowsTs($tableName, array $rowBatches, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_mutateRowsTs_args();
    $args->tableName = $tableName;
    $args->rowBatches = $rowBatches;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRowsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRowsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRowsTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_mutateRowsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_mutateRowsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function atomicIncrement($tableName, $row, $column, $value)
  {
    $this->send_atomicIncrement($tableName, $row, $column, $value);
    return $this->recv_atomicIncrement();
  }

  public function send_atomicIncrement($tableName, $row, $column, $value)
  {
    $args = new \Hbase\Hbase_atomicIncrement_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->value = $value;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'atomicIncrement', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('atomicIncrement', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_atomicIncrement()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_atomicIncrement_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_atomicIncrement_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new \Exception("atomicIncrement failed: unknown result");
  }

  public function deleteAll($tableName, $row, $column, array $attributes)
  {
    $this->send_deleteAll($tableName, $row, $column, $attributes);
    $this->recv_deleteAll();
  }

  public function send_deleteAll($tableName, $row, $column, array $attributes)
  {
    $args = new \Hbase\Hbase_deleteAll_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAll', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAll', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAll()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_deleteAll_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_deleteAll_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteAllTs($tableName, $row, $column, $timestamp, array $attributes)
  {
    $this->send_deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
    $this->recv_deleteAllTs();
  }

  public function send_deleteAllTs($tableName, $row, $column, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_deleteAllTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAllTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAllTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAllTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_deleteAllTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_deleteAllTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteAllRow($tableName, $row, array $attributes)
  {
    $this->send_deleteAllRow($tableName, $row, $attributes);
    $this->recv_deleteAllRow();
  }

  public function send_deleteAllRow($tableName, $row, array $attributes)
  {
    $args = new \Hbase\Hbase_deleteAllRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAllRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAllRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAllRow()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_deleteAllRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_deleteAllRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function increment(\Hbase\TIncrement $increment)
  {
    $this->send_increment($increment);
    $this->recv_increment();
  }

  public function send_increment(\Hbase\TIncrement $increment)
  {
    $args = new \Hbase\Hbase_increment_args();
    $args->increment = $increment;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'increment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('increment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_increment()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_increment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_increment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function incrementRows(array $increments)
  {
    $this->send_incrementRows($increments);
    $this->recv_incrementRows();
  }

  public function send_incrementRows(array $increments)
  {
    $args = new \Hbase\Hbase_incrementRows_args();
    $args->increments = $increments;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'incrementRows', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('incrementRows', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_incrementRows()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_incrementRows_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_incrementRows_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteAllRowTs($tableName, $row, $timestamp, array $attributes)
  {
    $this->send_deleteAllRowTs($tableName, $row, $timestamp, $attributes);
    $this->recv_deleteAllRowTs();
  }

  public function send_deleteAllRowTs($tableName, $row, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_deleteAllRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAllRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAllRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAllRowTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_deleteAllRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_deleteAllRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function scannerOpenWithScan($tableName, \Hbase\TScan $scan, array $attributes)
  {
    $this->send_scannerOpenWithScan($tableName, $scan, $attributes);
    return $this->recv_scannerOpenWithScan();
  }

  public function send_scannerOpenWithScan($tableName, \Hbase\TScan $scan, array $attributes)
  {
    $args = new \Hbase\Hbase_scannerOpenWithScan_args();
    $args->tableName = $tableName;
    $args->scan = $scan;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithScan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithScan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithScan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerOpenWithScan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerOpenWithScan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("scannerOpenWithScan failed: unknown result");
  }

  public function scannerOpen($tableName, $startRow, array $columns, array $attributes)
  {
    $this->send_scannerOpen($tableName, $startRow, $columns, $attributes);
    return $this->recv_scannerOpen();
  }

  public function send_scannerOpen($tableName, $startRow, array $columns, array $attributes)
  {
    $args = new \Hbase\Hbase_scannerOpen_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->columns = $columns;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpen', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpen', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpen()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerOpen_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerOpen_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("scannerOpen failed: unknown result");
  }

  public function scannerOpenWithStop($tableName, $startRow, $stopRow, array $columns, array $attributes)
  {
    $this->send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
    return $this->recv_scannerOpenWithStop();
  }

  public function send_scannerOpenWithStop($tableName, $startRow, $stopRow, array $columns, array $attributes)
  {
    $args = new \Hbase\Hbase_scannerOpenWithStop_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStop', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStop', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStop()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerOpenWithStop_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerOpenWithStop_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("scannerOpenWithStop failed: unknown result");
  }

  public function scannerOpenWithPrefix($tableName, $startAndPrefix, array $columns, array $attributes)
  {
    $this->send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
    return $this->recv_scannerOpenWithPrefix();
  }

  public function send_scannerOpenWithPrefix($tableName, $startAndPrefix, array $columns, array $attributes)
  {
    $args = new \Hbase\Hbase_scannerOpenWithPrefix_args();
    $args->tableName = $tableName;
    $args->startAndPrefix = $startAndPrefix;
    $args->columns = $columns;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithPrefix', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithPrefix', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithPrefix()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerOpenWithPrefix_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerOpenWithPrefix_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("scannerOpenWithPrefix failed: unknown result");
  }

  public function scannerOpenTs($tableName, $startRow, array $columns, $timestamp, array $attributes)
  {
    $this->send_scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
    return $this->recv_scannerOpenTs();
  }

  public function send_scannerOpenTs($tableName, $startRow, array $columns, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_scannerOpenTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerOpenTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerOpenTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("scannerOpenTs failed: unknown result");
  }

  public function scannerOpenWithStopTs($tableName, $startRow, $stopRow, array $columns, $timestamp, array $attributes)
  {
    $this->send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
    return $this->recv_scannerOpenWithStopTs();
  }

  public function send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, array $columns, $timestamp, array $attributes)
  {
    $args = new \Hbase\Hbase_scannerOpenWithStopTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStopTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStopTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStopTs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerOpenWithStopTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerOpenWithStopTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("scannerOpenWithStopTs failed: unknown result");
  }

  public function scannerGet($id)
  {
    $this->send_scannerGet($id);
    return $this->recv_scannerGet();
  }

  public function send_scannerGet($id)
  {
    $args = new \Hbase\Hbase_scannerGet_args();
    $args->id = $id;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerGet', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerGet', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerGet()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerGet_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerGet_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new \Exception("scannerGet failed: unknown result");
  }

  public function scannerGetList($id, $nbRows)
  {
    $this->send_scannerGetList($id, $nbRows);
    return $this->recv_scannerGetList();
  }

  public function send_scannerGetList($id, $nbRows)
  {
    $args = new \Hbase\Hbase_scannerGetList_args();
    $args->id = $id;
    $args->nbRows = $nbRows;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerGetList', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerGetList', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerGetList()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerGetList_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerGetList_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new \Exception("scannerGetList failed: unknown result");
  }

  public function scannerClose($id)
  {
    $this->send_scannerClose($id);
    $this->recv_scannerClose();
  }

  public function send_scannerClose($id)
  {
    $args = new \Hbase\Hbase_scannerClose_args();
    $args->id = $id;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerClose', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerClose', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerClose()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_scannerClose_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_scannerClose_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function getRegionInfo($row)
  {
    $this->send_getRegionInfo($row);
    return $this->recv_getRegionInfo();
  }

  public function send_getRegionInfo($row)
  {
    $args = new \Hbase\Hbase_getRegionInfo_args();
    $args->row = $row;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRegionInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRegionInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRegionInfo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_getRegionInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_getRegionInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("getRegionInfo failed: unknown result");
  }

  public function append(\Hbase\TAppend $append)
  {
    $this->send_append($append);
    return $this->recv_append();
  }

  public function send_append(\Hbase\TAppend $append)
  {
    $args = new \Hbase\Hbase_append_args();
    $args->append = $append;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_append_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_append_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new \Exception("append failed: unknown result");
  }

  public function checkAndPut($tableName, $row, $column, $value, \Hbase\Mutation $mput, array $attributes)
  {
    $this->send_checkAndPut($tableName, $row, $column, $value, $mput, $attributes);
    return $this->recv_checkAndPut();
  }

  public function send_checkAndPut($tableName, $row, $column, $value, \Hbase\Mutation $mput, array $attributes)
  {
    $args = new \Hbase\Hbase_checkAndPut_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->value = $value;
    $args->mput = $mput;
    $args->attributes = $attributes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'checkAndPut', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('checkAndPut', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_checkAndPut()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Hbase\Hbase_checkAndPut_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Hbase\Hbase_checkAndPut_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new \Exception("checkAndPut failed: unknown result");
  }

}


// HELPER FUNCTIONS AND STRUCTURES

class Hbase_enableTable_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * name of the table
   * 
   * @var string
   */
  public $tableName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_enableTable_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_enableTable_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_enableTable_args', self::$_TSPEC, $output);
  }

}

class Hbase_enableTable_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_enableTable_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_enableTable_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_enableTable_result', self::$_TSPEC, $output);
  }

}

class Hbase_disableTable_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * name of the table
   * 
   * @var string
   */
  public $tableName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_disableTable_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_disableTable_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_disableTable_args', self::$_TSPEC, $output);
  }

}

class Hbase_disableTable_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_disableTable_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_disableTable_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_disableTable_result', self::$_TSPEC, $output);
  }

}

class Hbase_isTableEnabled_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * name of the table to check
   * 
   * @var string
   */
  public $tableName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_isTableEnabled_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_isTableEnabled_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_isTableEnabled_args', self::$_TSPEC, $output);
  }

}

class Hbase_isTableEnabled_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_isTableEnabled_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_isTableEnabled_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_isTableEnabled_result', self::$_TSPEC, $output);
  }

}

class Hbase_compact_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableNameOrRegionName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $tableNameOrRegionName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_compact_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_compact_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_compact_args', self::$_TSPEC, $output);
  }

}

class Hbase_compact_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_compact_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_compact_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_compact_result', self::$_TSPEC, $output);
  }

}

class Hbase_majorCompact_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableNameOrRegionName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $tableNameOrRegionName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_majorCompact_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_majorCompact_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_majorCompact_args', self::$_TSPEC, $output);
  }

}

class Hbase_majorCompact_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_majorCompact_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_majorCompact_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_majorCompact_result', self::$_TSPEC, $output);
  }

}

class Hbase_getTableNames_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    );


  public function __construct() {
  }

  public function getName() {
    return 'Hbase_getTableNames_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getTableNames_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getTableNames_args', self::$_TSPEC, $output);
  }

}

class Hbase_getTableNames_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getTableNames_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getTableNames_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getTableNames_result', self::$_TSPEC, $output);
  }

}

class Hbase_getColumnDescriptors_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * table name
   * 
   * @var string
   */
  public $tableName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getColumnDescriptors_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getColumnDescriptors_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getColumnDescriptors_args', self::$_TSPEC, $output);
  }

}

class Hbase_getColumnDescriptors_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRUCT,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\ColumnDescriptor',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getColumnDescriptors_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getColumnDescriptors_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getColumnDescriptors_result', self::$_TSPEC, $output);
  }

}

class Hbase_getTableRegions_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * table name
   * 
   * @var string
   */
  public $tableName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getTableRegions_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getTableRegions_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getTableRegions_args', self::$_TSPEC, $output);
  }

}

class Hbase_getTableRegions_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRegionInfo',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRegionInfo[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getTableRegions_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getTableRegions_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getTableRegions_result', self::$_TSPEC, $output);
  }

}

class Hbase_createTable_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columnFamilies',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\ColumnDescriptor',
        ),
      ),
    );

  /**
   * name of table to create
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * list of column family descriptors
   * 
   * @var \Hbase\ColumnDescriptor[]
   */
  public $columnFamilies = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_createTable_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_createTable_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_createTable_args', self::$_TSPEC, $output);
  }

}

class Hbase_createTable_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    3 => array(
      'var' => 'exist',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\AlreadyExists',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;
  /**
   * @var \Hbase\AlreadyExists
   */
  public $exist = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_createTable_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_createTable_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_createTable_result', self::$_TSPEC, $output);
  }

}

class Hbase_deleteTable_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * name of table to delete
   * 
   * @var string
   */
  public $tableName = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteTable_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteTable_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteTable_args', self::$_TSPEC, $output);
  }

}

class Hbase_deleteTable_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteTable_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteTable_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteTable_result', self::$_TSPEC, $output);
  }

}

class Hbase_get_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * column name
   * 
   * @var string
   */
  public $column = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_get_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_get_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_get_args', self::$_TSPEC, $output);
  }

}

class Hbase_get_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TCell',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TCell[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_get_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_get_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_get_result', self::$_TSPEC, $output);
  }

}

class Hbase_getVer_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'numVersions',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * column name
   * 
   * @var string
   */
  public $column = null;
  /**
   * number of versions to retrieve
   * 
   * @var int
   */
  public $numVersions = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getVer_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getVer_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getVer_args', self::$_TSPEC, $output);
  }

}

class Hbase_getVer_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TCell',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TCell[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getVer_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getVer_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getVer_result', self::$_TSPEC, $output);
  }

}

class Hbase_getVerTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'numVersions',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    6 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * column name
   * 
   * @var string
   */
  public $column = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * number of versions to retrieve
   * 
   * @var int
   */
  public $numVersions = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getVerTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getVerTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getVerTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_getVerTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TCell',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TCell[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getVerTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getVerTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getVerTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRow_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRow_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRow_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRow_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRow_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRow_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRow_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRow_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRowWithColumns_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * List of columns to return, null for all columns
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumns_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowWithColumns_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowWithColumns_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRowWithColumns_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumns_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowWithColumns_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowWithColumns_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRowTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of the table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRowTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRowWithColumnsTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * List of columns to return, null for all columns
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnsTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowWithColumnsTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowWithColumnsTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRowWithColumnsTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnsTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowWithColumnsTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowWithColumnsTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRows_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'rows',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    3 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row keys
   * 
   * @var string[]
   */
  public $rows = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRows_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRows_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRows_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRows_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRows_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRows_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRows_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRowsWithColumns_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'rows',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row keys
   * 
   * @var string[]
   */
  public $rows = null;
  /**
   * List of columns to return, null for all columns
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumns_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowsWithColumns_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowsWithColumns_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRowsWithColumns_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumns_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowsWithColumns_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowsWithColumns_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRowsTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'rows',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of the table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row keys
   * 
   * @var string[]
   */
  public $rows = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowsTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowsTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowsTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRowsTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowsTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowsTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowsTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRowsWithColumnsTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'rows',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row keys
   * 
   * @var string[]
   */
  public $rows = null;
  /**
   * List of columns to return, null for all columns
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * Get attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumnsTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowsWithColumnsTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowsWithColumnsTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRowsWithColumnsTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumnsTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRowsWithColumnsTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRowsWithColumnsTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRow_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'mutations',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\Mutation',
        ),
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * list of mutation commands
   * 
   * @var \Hbase\Mutation[]
   */
  public $mutations = null;
  /**
   * Mutation attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRow_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRow_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRow_args', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRow_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRow_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRow_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRow_result', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRowTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'mutations',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\Mutation',
        ),
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * list of mutation commands
   * 
   * @var \Hbase\Mutation[]
   */
  public $mutations = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Mutation attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRowTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRowTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRowTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRowTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRowTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRowTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRowTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRows_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'rowBatches',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\BatchMutation',
        ),
      ),
    3 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * list of row batches
   * 
   * @var \Hbase\BatchMutation[]
   */
  public $rowBatches = null;
  /**
   * Mutation attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRows_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRows_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRows_args', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRows_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRows_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRows_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRows_result', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRowsTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'rowBatches',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\BatchMutation',
        ),
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * list of row batches
   * 
   * @var \Hbase\BatchMutation[]
   */
  public $rowBatches = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Mutation attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRowsTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRowsTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRowsTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_mutateRowsTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_mutateRowsTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_mutateRowsTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_mutateRowsTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_atomicIncrement_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row to increment
   * 
   * @var string
   */
  public $row = null;
  /**
   * name of column
   * 
   * @var string
   */
  public $column = null;
  /**
   * amount to increment by
   * 
   * @var int
   */
  public $value = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_atomicIncrement_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_atomicIncrement_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_atomicIncrement_args', self::$_TSPEC, $output);
  }

}

class Hbase_atomicIncrement_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_atomicIncrement_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_atomicIncrement_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_atomicIncrement_result', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAll_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Row to update
   * 
   * @var string
   */
  public $row = null;
  /**
   * name of column whose value is to be deleted
   * 
   * @var string
   */
  public $column = null;
  /**
   * Delete attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAll_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAll_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAll_args', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAll_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAll_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAll_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAll_result', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAllTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Row to update
   * 
   * @var string
   */
  public $row = null;
  /**
   * name of column whose value is to be deleted
   * 
   * @var string
   */
  public $column = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Delete attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAllTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAllTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAllTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAllTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAllTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAllTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAllTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAllRow_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * key of the row to be completely deleted.
   * 
   * @var string
   */
  public $row = null;
  /**
   * Delete attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRow_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAllRow_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAllRow_args', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAllRow_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRow_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAllRow_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAllRow_result', self::$_TSPEC, $output);
  }

}

class Hbase_increment_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'increment',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\TIncrement',
      ),
    );

  /**
   * The single increment to apply
   * 
   * @var \Hbase\TIncrement
   */
  public $increment = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_increment_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_increment_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_increment_args', self::$_TSPEC, $output);
  }

}

class Hbase_increment_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_increment_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_increment_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_increment_result', self::$_TSPEC, $output);
  }

}

class Hbase_incrementRows_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'increments',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TIncrement',
        ),
      ),
    );

  /**
   * The list of increments
   * 
   * @var \Hbase\TIncrement[]
   */
  public $increments = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_incrementRows_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_incrementRows_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_incrementRows_args', self::$_TSPEC, $output);
  }

}

class Hbase_incrementRows_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_incrementRows_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_incrementRows_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_incrementRows_result', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAllRowTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * key of the row to be completely deleted.
   * 
   * @var string
   */
  public $row = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Delete attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRowTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAllRowTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAllRowTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_deleteAllRowTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRowTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_deleteAllRowTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_deleteAllRowTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithScan_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'scan',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\TScan',
      ),
    3 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Scan instance
   * 
   * @var \Hbase\TScan
   */
  public $scan = null;
  /**
   * Scan attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithScan_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithScan_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithScan_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithScan_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithScan_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithScan_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithScan_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpen_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'startRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @var string
   */
  public $startRow = null;
  /**
   * columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * Scan attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpen_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpen_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpen_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpen_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpen_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpen_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpen_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithStop_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'startRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'stopRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @var string
   */
  public $startRow = null;
  /**
   * row to stop scanning on. This row is *not* included in the
   * scanner's results
   * 
   * @var string
   */
  public $stopRow = null;
  /**
   * columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * Scan attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStop_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithStop_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithStop_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithStop_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStop_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithStop_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithStop_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithPrefix_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'startAndPrefix',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * the prefix (and thus start row) of the keys you want
   * 
   * @var string
   */
  public $startAndPrefix = null;
  /**
   * the columns you want returned
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * Scan attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithPrefix_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithPrefix_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithPrefix_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithPrefix_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithPrefix_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithPrefix_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithPrefix_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'startRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @var string
   */
  public $startRow = null;
  /**
   * columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Scan attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithStopTs_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'startRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'stopRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    5 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    6 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @var string
   */
  public $startRow = null;
  /**
   * row to stop scanning on. This row is *not* included in the
   * scanner's results
   * 
   * @var string
   */
  public $stopRow = null;
  /**
   * columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @var string[]
   */
  public $columns = null;
  /**
   * timestamp
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Scan attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopTs_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithStopTs_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithStopTs_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerOpenWithStopTs_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopTs_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerOpenWithStopTs_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerOpenWithStopTs_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerGet_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * id of a scanner returned by scannerOpen
   * 
   * @var int
   */
  public $id = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerGet_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerGet_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerGet_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerGet_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerGet_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerGet_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerGet_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerGetList_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    2 => array(
      'var' => 'nbRows',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * id of a scanner returned by scannerOpen
   * 
   * @var int
   */
  public $id = null;
  /**
   * number of results to return
   * 
   * @var int
   */
  public $nbRows = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerGetList_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerGetList_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerGetList_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerGetList_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TRowResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\TRowResult[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerGetList_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerGetList_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerGetList_result', self::$_TSPEC, $output);
  }

}

class Hbase_scannerClose_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * id of a scanner returned by scannerOpen
   * 
   * @var int
   */
  public $id = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerClose_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerClose_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerClose_args', self::$_TSPEC, $output);
  }

}

class Hbase_scannerClose_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_scannerClose_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_scannerClose_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_scannerClose_result', self::$_TSPEC, $output);
  }

}

class Hbase_getRegionInfo_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * row key
   * 
   * @var string
   */
  public $row = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRegionInfo_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRegionInfo_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRegionInfo_args', self::$_TSPEC, $output);
  }

}

class Hbase_getRegionInfo_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\TRegionInfo',
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TRegionInfo
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_getRegionInfo_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_getRegionInfo_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_getRegionInfo_result', self::$_TSPEC, $output);
  }

}

class Hbase_append_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'append',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\TAppend',
      ),
    );

  /**
   * The single append operation to apply
   * 
   * @var \Hbase\TAppend
   */
  public $append = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_append_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_append_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_append_args', self::$_TSPEC, $output);
  }

}

class Hbase_append_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TCell',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    );

  /**
   * @var \Hbase\TCell[]
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_append_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_append_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_append_result', self::$_TSPEC, $output);
  }

}

class Hbase_checkAndPut_args extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'tableName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    5 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    6 => array(
      'var' => 'mput',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\Mutation',
      ),
    7 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * name of table
   * 
   * @var string
   */
  public $tableName = null;
  /**
   * row key
   * 
   * @var string
   */
  public $row = null;
  /**
   * column name
   * 
   * @var string
   */
  public $column = null;
  /**
   * the expected value for the column parameter, if not
   * provided the check is for the non-existence of the
   * column in question
   * 
   * @var string
   */
  public $value = null;
  /**
   * mutation for the pick
   * 
   * @var \Hbase\Mutation
   */
  public $mput = null;
  /**
   * Mutation attributes
   * 
   * @var array
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_checkAndPut_args';
  }

  public function read($input)
  {
    return $this->_read('Hbase_checkAndPut_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_checkAndPut_args', self::$_TSPEC, $output);
  }

}

class Hbase_checkAndPut_result extends TBase {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\IllegalArgument',
      ),
    );

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \Hbase\IOError
   */
  public $io = null;
  /**
   * @var \Hbase\IllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Hbase_checkAndPut_result';
  }

  public function read($input)
  {
    return $this->_read('Hbase_checkAndPut_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Hbase_checkAndPut_result', self::$_TSPEC, $output);
  }

}


